{"version":3,"file":"8340.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyter/ydoc/lib/ymodels.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyter/ydoc/lib/utils.js"],"sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { JSONExt, UUID } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { Awareness } from 'y-protocols/awareness';\nimport * as Y from 'yjs';\n/**\n * Generic shareable document.\n */\nexport class YDocument {\n    constructor() {\n        /**\n         * YJS document\n         */\n        this.ydoc = new Y.Doc();\n        /**\n         * Shared state\n         */\n        this.ystate = this.ydoc.getMap('state');\n        /**\n         * YJS document undo manager\n         */\n        this.undoManager = new Y.UndoManager([], {\n            trackedOrigins: new Set([this]),\n            doc: this.ydoc\n        });\n        /**\n         * Shared awareness\n         */\n        this.awareness = new Awareness(this.ydoc);\n        /**\n         * Handle a change to the ystate.\n         */\n        this.onStateChanged = (event) => {\n            const stateChange = new Array();\n            event.keysChanged.forEach(key => {\n                const change = event.changes.keys.get(key);\n                if (change) {\n                    stateChange.push({\n                        name: key,\n                        oldValue: change.oldValue,\n                        newValue: this.ystate.get(key)\n                    });\n                }\n            });\n            this._changed.emit({ stateChange });\n        };\n        this._changed = new Signal(this);\n        this._isDisposed = false;\n        this.ystate.observe(this.onStateChanged);\n    }\n    /**\n     * The changed signal.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Whether the document is disposed or not.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Document state\n     */\n    get state() {\n        return JSONExt.deepCopy(this.ystate.toJSON());\n    }\n    /**\n     * Whether the object can undo changes.\n     */\n    canUndo() {\n        return this.undoManager.undoStack.length > 0;\n    }\n    /**\n     * Whether the object can redo changes.\n     */\n    canRedo() {\n        return this.undoManager.redoStack.length > 0;\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this.ystate.unobserve(this.onStateChanged);\n        this.awareness.destroy();\n        this.undoManager.destroy();\n        this.ydoc.destroy();\n        Signal.clearData(this);\n    }\n    /**\n     * Get the value for a state attribute\n     *\n     * @param key Key to get\n     */\n    getState(key) {\n        const value = this.ystate.get(key);\n        return typeof value === 'undefined'\n            ? value\n            : JSONExt.deepCopy(value);\n    }\n    /**\n     * Set the value of a state attribute\n     *\n     * @param key Key to set\n     * @param value New attribute value\n     */\n    setState(key, value) {\n        if (!JSONExt.deepEqual(this.ystate.get(key), value)) {\n            this.ystate.set(key, value);\n        }\n    }\n    /**\n     * Undo an operation.\n     */\n    undo() {\n        this.undoManager.undo();\n    }\n    /**\n     * Redo an operation.\n     */\n    redo() {\n        this.undoManager.redo();\n    }\n    /**\n     * Clear the change stack.\n     */\n    clearUndoHistory() {\n        this.undoManager.clear();\n    }\n    /**\n     * Perform a transaction. While the function f is called, all changes to the shared\n     * document are bundled into a single event.\n     */\n    transact(f, undoable = true) {\n        this.ydoc.transact(f, undoable ? this : null);\n    }\n}\n/**\n * Shareable text file.\n */\nexport class YFile extends YDocument {\n    /**\n     * Create a new file\n     *\n     * #### Notes\n     * The document is empty and must be populated\n     */\n    constructor() {\n        super();\n        /**\n         * YJS file text.\n         */\n        this.ysource = this.ydoc.getText('source');\n        /**\n         * Handle a change to the ymodel.\n         */\n        this._modelObserver = (event) => {\n            this._changed.emit({ sourceChange: event.changes.delta });\n        };\n        this.undoManager.addToScope(this.ysource);\n        this.ysource.observe(this._modelObserver);\n    }\n    /**\n     * File text\n     */\n    get source() {\n        return this.getSource();\n    }\n    set source(v) {\n        this.setSource(v);\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.ysource.unobserve(this._modelObserver);\n        super.dispose();\n    }\n    /**\n     * Get the file text.\n     *\n     * @returns File text.\n     */\n    getSource() {\n        return this.ysource.toString();\n    }\n    /**\n     * Set the file text.\n     *\n     * @param value New text\n     */\n    setSource(value) {\n        this.transact(() => {\n            const ytext = this.ysource;\n            ytext.delete(0, ytext.length);\n            ytext.insert(0, value);\n        });\n    }\n    /**\n     * Replace content from `start' to `end` with `value`.\n     *\n     * @param start: The start index of the range to replace (inclusive).\n     * @param end: The end index of the range to replace (exclusive).\n     * @param value: New source (optional).\n     */\n    updateSource(start, end, value = '') {\n        this.transact(() => {\n            const ysource = this.ysource;\n            // insert and then delete.\n            // This ensures that the cursor position is adjusted after the replaced content.\n            ysource.insert(start, value);\n            ysource.delete(start + value.length, end - start);\n        });\n    }\n}\n/**\n * Create a new shared cell model given the YJS shared type.\n */\nconst createCellModelFromSharedType = (type, options = {}) => {\n    switch (type.get('cell_type')) {\n        case 'code':\n            return new YCodeCell(type, type.get('source'), type.get('outputs'), options);\n        case 'markdown':\n            return new YMarkdownCell(type, type.get('source'), options);\n        case 'raw':\n            return new YRawCell(type, type.get('source'), options);\n        default:\n            throw new Error('Found unknown cell type');\n    }\n};\n/**\n * Create a new cell that can be inserted in an existing shared model.\n *\n * If no notebook is specified the cell will be standalone.\n *\n * @param cell Cell JSON representation\n * @param notebook Notebook to which the cell will be added\n */\nconst createCell = (cell, notebook) => {\n    var _a, _b;\n    const ymodel = new Y.Map();\n    const ysource = new Y.Text();\n    ymodel.set('source', ysource);\n    ymodel.set('metadata', {});\n    ymodel.set('cell_type', cell.cell_type);\n    ymodel.set('id', (_a = cell.id) !== null && _a !== void 0 ? _a : UUID.uuid4());\n    let ycell;\n    switch (cell.cell_type) {\n        case 'markdown': {\n            ycell = new YMarkdownCell(ymodel, ysource, { notebook });\n            if (cell.attachments != null) {\n                ycell.setAttachments(cell.attachments);\n            }\n            break;\n        }\n        case 'code': {\n            const youtputs = new Y.Array();\n            ymodel.set('outputs', youtputs);\n            ycell = new YCodeCell(ymodel, ysource, youtputs, {\n                notebook\n            });\n            const cCell = cell;\n            ycell.execution_count = (_b = cCell.execution_count) !== null && _b !== void 0 ? _b : null;\n            if (cCell.outputs) {\n                ycell.setOutputs(cCell.outputs);\n            }\n            break;\n        }\n        default: {\n            // raw\n            ycell = new YRawCell(ymodel, ysource, { notebook });\n            if (cell.attachments) {\n                ycell.setAttachments(cell.attachments);\n            }\n            break;\n        }\n    }\n    if (cell.metadata != null) {\n        ycell.setMetadata(cell.metadata);\n    }\n    if (cell.source != null) {\n        ycell.setSource(typeof cell.source === 'string' ? cell.source : cell.source.join('\\n'));\n    }\n    return ycell;\n};\n/**\n * Create a new cell that cannot be inserted in an existing shared model.\n *\n * @param cell Cell JSON representation\n */\nexport const createStandaloneCell = (cell) => createCell(cell);\nexport class YBaseCell {\n    /**\n     * Create a new YCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static createStandalone(id) {\n        return createCell({ id, cell_type: this.prototype.cell_type });\n    }\n    /**\n     * Base cell constructor\n     *\n     * ### Notes\n     * Don't use the constructor directly - prefer using ``YNotebook.insertCell``\n     *\n     * The ``ysource`` is needed because ``ymodel.get('source')`` will\n     * not return the real source if the model is not yet attached to\n     * a document. Requesting it explicitly allows to introspect a non-empty\n     * source before the cell is attached to the document.\n     *\n     * @param ymodel Cell map\n     * @param ysource Cell source\n     * @param options { notebook?: The notebook the cell is attached to }\n     */\n    constructor(ymodel, ysource, options = {}) {\n        /**\n         * Handle a change to the ymodel.\n         */\n        this._modelObserver = (events) => {\n            this._changed.emit(this.getChanges(events));\n        };\n        this._metadataChanged = new Signal(this);\n        /**\n         * The notebook that this cell belongs to.\n         */\n        this._notebook = null;\n        this._changed = new Signal(this);\n        this._disposed = new Signal(this);\n        this._isDisposed = false;\n        this._undoManager = null;\n        this.ymodel = ymodel;\n        this._ysource = ysource;\n        this._prevSourceLength = ysource ? ysource.length : 0;\n        this._notebook = null;\n        this._awareness = null;\n        this._undoManager = null;\n        if (options.notebook) {\n            this._notebook = options.notebook;\n            // We cannot create a undo manager with the cell not yet attached in the notebook\n            // so we defer that to the notebook insertCell method\n        }\n        else {\n            // Standalone cell\n            const doc = new Y.Doc();\n            doc.getArray().insert(0, [this.ymodel]);\n            this._awareness = new Awareness(doc);\n            this._undoManager = new Y.UndoManager([this.ymodel], {\n                trackedOrigins: new Set([this])\n            });\n        }\n        this.ymodel.observeDeep(this._modelObserver);\n    }\n    /**\n     * Cell notebook awareness or null if the cell is standalone.\n     */\n    get awareness() {\n        var _a, _b, _c;\n        return (_c = (_a = this._awareness) !== null && _a !== void 0 ? _a : (_b = this.notebook) === null || _b === void 0 ? void 0 : _b.awareness) !== null && _c !== void 0 ? _c : null;\n    }\n    /**\n     * The type of the cell.\n     */\n    get cell_type() {\n        throw new Error('A YBaseCell must not be constructed');\n    }\n    /**\n     * The changed signal.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Signal emitted when the cell is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Cell id\n     */\n    get id() {\n        return this.getId();\n    }\n    /**\n     * Whether the model has been disposed or not.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Whether the cell is standalone or not.\n     *\n     * If the cell is standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    get isStandalone() {\n        return this._notebook !== null;\n    }\n    /**\n     * Cell metadata.\n     */\n    get metadata() {\n        return this.getMetadata();\n    }\n    set metadata(v) {\n        this.setMetadata(v);\n    }\n    /**\n     * Signal triggered when the cell metadata changes.\n     */\n    get metadataChanged() {\n        return this._metadataChanged;\n    }\n    /**\n     * The notebook that this cell belongs to.\n     */\n    get notebook() {\n        return this._notebook;\n    }\n    /**\n     * Cell input content.\n     */\n    get source() {\n        return this.getSource();\n    }\n    set source(v) {\n        this.setSource(v);\n    }\n    /**\n     * The cell undo manager.\n     */\n    get undoManager() {\n        var _a;\n        if (!this.notebook) {\n            return this._undoManager;\n        }\n        return ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.disableDocumentWideUndoRedo)\n            ? this._undoManager\n            : this.notebook.undoManager;\n    }\n    /**\n     * Defer setting the undo manager as it requires the\n     * cell to be attached to the notebook Y document.\n     */\n    setUndoManager() {\n        if (this._undoManager) {\n            throw new Error('The cell undo manager is already set.');\n        }\n        if (this._notebook && this._notebook.disableDocumentWideUndoRedo) {\n            this._undoManager = new Y.UndoManager([this.ymodel], {\n                trackedOrigins: new Set([this])\n            });\n        }\n    }\n    get ysource() {\n        return this._ysource;\n    }\n    /**\n     * Whether the object can undo changes.\n     */\n    canUndo() {\n        return !!this.undoManager && this.undoManager.undoStack.length > 0;\n    }\n    /**\n     * Whether the object can redo changes.\n     */\n    canRedo() {\n        return !!this.undoManager && this.undoManager.redoStack.length > 0;\n    }\n    /**\n     * Clear the change stack.\n     */\n    clearUndoHistory() {\n        var _a;\n        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n    /**\n     * Undo an operation.\n     */\n    undo() {\n        var _a;\n        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.undo();\n    }\n    /**\n     * Redo an operation.\n     */\n    redo() {\n        var _a;\n        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.redo();\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        var _a;\n        if (this._isDisposed)\n            return;\n        this._isDisposed = true;\n        this.ymodel.unobserveDeep(this._modelObserver);\n        if (this._awareness) {\n            // A new document is created for standalone cell.\n            const doc = this._awareness.doc;\n            this._awareness.destroy();\n            doc.destroy();\n        }\n        if (this._undoManager) {\n            // Be sure to not destroy the document undo manager.\n            if (this._undoManager === ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.undoManager)) {\n                this._undoManager = null;\n            }\n            else {\n                this._undoManager.destroy();\n            }\n        }\n        this._disposed.emit();\n        Signal.clearData(this);\n    }\n    /**\n     * Get cell id.\n     *\n     * @returns Cell id\n     */\n    getId() {\n        return this.ymodel.get('id');\n    }\n    /**\n     * Gets cell's source.\n     *\n     * @returns Cell's source.\n     */\n    getSource() {\n        return this.ysource.toString();\n    }\n    /**\n     * Sets cell's source.\n     *\n     * @param value: New source.\n     */\n    setSource(value) {\n        this.transact(() => {\n            this.ysource.delete(0, this.ysource.length);\n            this.ysource.insert(0, value);\n        });\n        // @todo Do we need proper replace semantic? This leads to issues in editor bindings because they don't switch source.\n        // this.ymodel.set('source', new Y.Text(value));\n    }\n    /**\n     * Replace content from `start' to `end` with `value`.\n     *\n     * @param start: The start index of the range to replace (inclusive).\n     *\n     * @param end: The end index of the range to replace (exclusive).\n     *\n     * @param value: New source (optional).\n     */\n    updateSource(start, end, value = '') {\n        this.transact(() => {\n            const ysource = this.ysource;\n            // insert and then delete.\n            // This ensures that the cursor position is adjusted after the replaced content.\n            ysource.insert(start, value);\n            ysource.delete(start + value.length, end - start);\n        });\n    }\n    /**\n     * Delete a metadata cell.\n     *\n     * @param key The key to delete\n     */\n    deleteMetadata(key) {\n        if (typeof this.getMetadata(key) === 'undefined') {\n            return;\n        }\n        const allMetadata = JSONExt.deepCopy(this.ymodel.get('metadata'));\n        delete allMetadata[key];\n        if (key === 'collapsed' && allMetadata.jupyter) {\n            delete allMetadata.jupyter.outputs_hidden;\n            if (Object.keys(allMetadata.jupyter).length === 0) {\n                delete allMetadata.jupyter;\n            }\n        }\n        else if (key === 'jupyter') {\n            delete allMetadata.collapsed;\n        }\n        this.setMetadata(allMetadata);\n    }\n    getMetadata(key) {\n        var _a;\n        // Transiently the metadata can be missing - like during destruction\n        const metadata = (_a = this.ymodel.get('metadata')) !== null && _a !== void 0 ? _a : {};\n        if (typeof key === 'string') {\n            const value = metadata[key];\n            return typeof value === 'undefined'\n                ? undefined // undefined is converted to `{}` by `JSONExt.deepCopy`\n                : JSONExt.deepCopy(metadata[key]);\n        }\n        else {\n            return JSONExt.deepCopy(metadata);\n        }\n    }\n    setMetadata(metadata, value) {\n        var _a, _b, _c;\n        if (typeof metadata === 'string') {\n            if (typeof value === 'undefined') {\n                throw new TypeError(`Metadata value for ${metadata} cannot be 'undefined'; use deleteMetadata.`);\n            }\n            const key = metadata;\n            // Only set metadata if we change something to avoid infinite\n            // loop of signal changes.\n            if (JSONExt.deepEqual((_a = this.getMetadata(key)) !== null && _a !== void 0 ? _a : null, value)) {\n                return;\n            }\n            const clone = this.getMetadata();\n            clone[key] = value;\n            if (key === 'collapsed' && ((_b = clone.jupyter) === null || _b === void 0 ? void 0 : _b.outputs_hidden) !== value) {\n                clone.jupyter = {\n                    ...clone.jupyter,\n                    outputs_hidden: value\n                };\n            }\n            else if (key === 'jupyter') {\n                if (typeof value['outputs_hidden'] !== 'undefined') {\n                    if (clone.collapsed !== value['outputs_hidden']) {\n                        clone.collapsed = value['outputs_hidden'];\n                    }\n                }\n                else {\n                    delete clone.collapsed;\n                }\n            }\n            this.transact(() => {\n                this.ymodel.set('metadata', clone);\n            });\n        }\n        else {\n            const clone = JSONExt.deepCopy(metadata);\n            if (clone.collapsed != null) {\n                clone.jupyter = clone.jupyter || {};\n                clone.jupyter.outputs_hidden = clone.collapsed;\n            }\n            else if (((_c = clone === null || clone === void 0 ? void 0 : clone.jupyter) === null || _c === void 0 ? void 0 : _c.outputs_hidden) != null) {\n                clone.collapsed = clone.jupyter.outputs_hidden;\n            }\n            if (!JSONExt.deepEqual(clone, this.getMetadata())) {\n                this.transact(() => {\n                    this.ymodel.set('metadata', clone);\n                });\n            }\n        }\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: this.cell_type,\n            source: this.getSource(),\n            metadata: this.getMetadata()\n        };\n    }\n    /**\n     * Perform a transaction. While the function f is called, all changes to the shared\n     * document are bundled into a single event.\n     */\n    transact(f, undoable = true) {\n        this.notebook && undoable\n            ? this.notebook.transact(f)\n            : this.ymodel.doc == null\n                ? f()\n                : this.ymodel.doc.transact(f, this);\n    }\n    /**\n     * Extract changes from YJS events\n     *\n     * @param events YJS events\n     * @returns Cell changes\n     */\n    getChanges(events) {\n        var _a;\n        const changes = {};\n        const sourceEvent = events.find(event => event.target === this.ymodel.get('source'));\n        if (sourceEvent) {\n            changes.sourceChange = sourceEvent.changes.delta;\n        }\n        const modelEvent = events.find(event => event.target === this.ymodel);\n        if (modelEvent && modelEvent.keysChanged.has('metadata')) {\n            const change = modelEvent.changes.keys.get('metadata');\n            const metadataChange = (changes.metadataChange = {\n                oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,\n                newValue: this.getMetadata()\n            });\n            const oldValue = (_a = metadataChange.oldValue) !== null && _a !== void 0 ? _a : {};\n            const oldKeys = Object.keys(oldValue);\n            const newKeys = Object.keys(metadataChange.newValue);\n            for (let key of new Set(oldKeys.concat(newKeys))) {\n                if (!oldKeys.includes(key)) {\n                    this._metadataChanged.emit({\n                        key,\n                        newValue: metadataChange.newValue[key],\n                        type: 'add'\n                    });\n                }\n                else if (!newKeys.includes(key)) {\n                    this._metadataChanged.emit({\n                        key,\n                        oldValue: metadataChange.oldValue[key],\n                        type: 'remove'\n                    });\n                }\n                else if (!JSONExt.deepEqual(oldValue[key], metadataChange.newValue[key])) {\n                    this._metadataChanged.emit({\n                        key,\n                        newValue: metadataChange.newValue[key],\n                        oldValue: metadataChange.oldValue[key],\n                        type: 'change'\n                    });\n                }\n            }\n        }\n        // The model allows us to replace the complete source with a new string. We express this in the Delta format\n        // as a replace of the complete string.\n        const ysource = this.ymodel.get('source');\n        if (modelEvent && modelEvent.keysChanged.has('source')) {\n            changes.sourceChange = [\n                { delete: this._prevSourceLength },\n                { insert: ysource.toString() }\n            ];\n        }\n        this._prevSourceLength = ysource.length;\n        return changes;\n    }\n}\n/**\n * Shareable code cell.\n */\nexport class YCodeCell extends YBaseCell {\n    /**\n     * Create a new YCodeCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static createStandalone(id) {\n        return super.createStandalone(id);\n    }\n    /**\n     * Code cell constructor\n     *\n     * ### Notes\n     * Don't use the constructor directly - prefer using ``YNotebook.insertCell``\n     *\n     * The ``ysource`` is needed because ``ymodel.get('source')`` will\n     * not return the real source if the model is not yet attached to\n     * a document. Requesting it explicitly allows to introspect a non-empty\n     * source before the cell is attached to the document.\n     *\n     * @param ymodel Cell map\n     * @param ysource Cell source\n     * @param youtputs Code cell outputs\n     * @param options { notebook?: The notebook the cell is attached to }\n     */\n    constructor(ymodel, ysource, youtputs, options = {}) {\n        super(ymodel, ysource, options);\n        this._youtputs = youtputs;\n    }\n    /**\n     * The type of the cell.\n     */\n    get cell_type() {\n        return 'code';\n    }\n    /**\n     * The code cell's prompt number. Will be null if the cell has not been run.\n     */\n    get execution_count() {\n        return this.ymodel.get('execution_count') || null;\n    }\n    set execution_count(count) {\n        // Do not use `this.execution_count`. When initializing the\n        // cell, we need to set execution_count to `null` if we compare\n        // using `this.execution_count` it will return `null` and we will\n        // never initialize it\n        if (this.ymodel.get('execution_count') !== count) {\n            this.transact(() => {\n                this.ymodel.set('execution_count', count);\n            });\n        }\n    }\n    /**\n     * Cell outputs.\n     */\n    get outputs() {\n        return this.getOutputs();\n    }\n    set outputs(v) {\n        this.setOutputs(v);\n    }\n    /**\n     * Execution, display, or stream outputs.\n     */\n    getOutputs() {\n        return JSONExt.deepCopy(this._youtputs.toArray());\n    }\n    /**\n     * Replace all outputs.\n     */\n    setOutputs(outputs) {\n        this.transact(() => {\n            this._youtputs.delete(0, this._youtputs.length);\n            this._youtputs.insert(0, outputs);\n        }, false);\n    }\n    /**\n     * Replace content from `start' to `end` with `outputs`.\n     *\n     * @param start: The start index of the range to replace (inclusive).\n     *\n     * @param end: The end index of the range to replace (exclusive).\n     *\n     * @param outputs: New outputs (optional).\n     */\n    updateOutputs(start, end, outputs = []) {\n        const fin = end < this._youtputs.length ? end - start : this._youtputs.length - start;\n        this.transact(() => {\n            this._youtputs.delete(start, fin);\n            this._youtputs.insert(start, outputs);\n        }, false);\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            outputs: this.getOutputs(),\n            execution_count: this.execution_count\n        };\n    }\n    /**\n     * Extract changes from YJS events\n     *\n     * @param events YJS events\n     * @returns Cell changes\n     */\n    getChanges(events) {\n        const changes = super.getChanges(events);\n        const outputEvent = events.find(event => event.target === this.ymodel.get('outputs'));\n        if (outputEvent) {\n            changes.outputsChange = outputEvent.changes.delta;\n        }\n        const modelEvent = events.find(event => event.target === this.ymodel);\n        if (modelEvent && modelEvent.keysChanged.has('execution_count')) {\n            const change = modelEvent.changes.keys.get('execution_count');\n            changes.executionCountChange = {\n                oldValue: change.oldValue,\n                newValue: this.ymodel.get('execution_count')\n            };\n        }\n        return changes;\n    }\n}\nclass YAttachmentCell extends YBaseCell {\n    /**\n     * Cell attachments\n     */\n    get attachments() {\n        return this.getAttachments();\n    }\n    set attachments(v) {\n        this.setAttachments(v);\n    }\n    /**\n     * Gets the cell attachments.\n     *\n     * @returns The cell attachments.\n     */\n    getAttachments() {\n        return this.ymodel.get('attachments');\n    }\n    /**\n     * Sets the cell attachments\n     *\n     * @param attachments: The cell attachments.\n     */\n    setAttachments(attachments) {\n        this.transact(() => {\n            if (attachments == null) {\n                this.ymodel.delete('attachments');\n            }\n            else {\n                this.ymodel.set('attachments', attachments);\n            }\n        });\n    }\n    /**\n     * Extract changes from YJS events\n     *\n     * @param events YJS events\n     * @returns Cell changes\n     */\n    getChanges(events) {\n        const changes = super.getChanges(events);\n        const modelEvent = events.find(event => event.target === this.ymodel);\n        if (modelEvent && modelEvent.keysChanged.has('attachments')) {\n            const change = modelEvent.changes.keys.get('attachments');\n            changes.executionCountChange = {\n                oldValue: change.oldValue,\n                newValue: this.ymodel.get('attachments')\n            };\n        }\n        return changes;\n    }\n}\n/**\n * Shareable raw cell.\n */\nexport class YRawCell extends YAttachmentCell {\n    /**\n     * Create a new YRawCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static createStandalone(id) {\n        return super.createStandalone(id);\n    }\n    /**\n     * String identifying the type of cell.\n     */\n    get cell_type() {\n        return 'raw';\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: 'raw',\n            source: this.getSource(),\n            metadata: this.getMetadata(),\n            attachments: this.getAttachments()\n        };\n    }\n}\n/**\n * Shareable markdown cell.\n */\nexport class YMarkdownCell extends YAttachmentCell {\n    /**\n     * Create a new YMarkdownCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static createStandalone(id) {\n        return super.createStandalone(id);\n    }\n    /**\n     * String identifying the type of cell.\n     */\n    get cell_type() {\n        return 'markdown';\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: 'markdown',\n            source: this.getSource(),\n            metadata: this.getMetadata(),\n            attachments: this.getAttachments()\n        };\n    }\n}\n/**\n * Shared implementation of the Shared Document types.\n *\n * Shared cells can be inserted into a SharedNotebook.\n * Shared cells only start emitting events when they are connected to a SharedNotebook.\n *\n * \"Standalone\" cells must not be inserted into a (Shared)Notebook.\n * Standalone cells emit events immediately after they have been created, but they must not\n * be included into a (Shared)Notebook.\n */\nexport class YNotebook extends YDocument {\n    /**\n     * Create a new notebook\n     *\n     * #### Notes\n     * The document is empty and must be populated\n     *\n     * @param options\n     */\n    constructor(options = {}) {\n        var _a;\n        super();\n        /**\n         * YJS map for the notebook metadata\n         */\n        this.ymeta = this.ydoc.getMap('meta');\n        /**\n         * Handle a change to the ystate.\n         */\n        this._onMetaChanged = (event) => {\n            var _a;\n            if (event.keysChanged.has('metadata')) {\n                const change = event.changes.keys.get('metadata');\n                const metadataChange = {\n                    oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,\n                    newValue: this.getMetadata()\n                };\n                const oldValue = (_a = metadataChange.oldValue) !== null && _a !== void 0 ? _a : {};\n                const oldKeys = Object.keys(oldValue);\n                const newKeys = Object.keys(metadataChange.newValue);\n                for (let key of new Set(oldKeys.concat(newKeys))) {\n                    if (!oldKeys.includes(key)) {\n                        this._metadataChanged.emit({\n                            key,\n                            newValue: metadataChange.newValue[key],\n                            type: 'add'\n                        });\n                    }\n                    else if (!newKeys.includes(key)) {\n                        this._metadataChanged.emit({\n                            key,\n                            oldValue: metadataChange.oldValue[key],\n                            type: 'remove'\n                        });\n                    }\n                    else if (!JSONExt.deepEqual(oldValue[key], metadataChange.newValue[key])) {\n                        this._metadataChanged.emit({\n                            key,\n                            newValue: metadataChange.newValue[key],\n                            oldValue: metadataChange.oldValue[key],\n                            type: 'change'\n                        });\n                    }\n                }\n                this._changed.emit({ metadataChange });\n            }\n            if (event.keysChanged.has('nbformat')) {\n                const change = event.changes.keys.get('nbformat');\n                const nbformatChanged = {\n                    key: 'nbformat',\n                    oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,\n                    newValue: this.nbformat\n                };\n                this._changed.emit({ nbformatChanged });\n            }\n            if (event.keysChanged.has('nbformat_minor')) {\n                const change = event.changes.keys.get('nbformat_minor');\n                const nbformatChanged = {\n                    key: 'nbformat_minor',\n                    oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,\n                    newValue: this.nbformat_minor\n                };\n                this._changed.emit({ nbformatChanged });\n            }\n        };\n        /**\n         * Handle a change to the list of cells.\n         */\n        this._onYCellsChanged = (event) => {\n            // update the type cell mapping by iterating through the added/removed types\n            event.changes.added.forEach(item => {\n                const type = item.content.type;\n                if (!this._ycellMapping.has(type)) {\n                    const c = createCellModelFromSharedType(type, { notebook: this });\n                    c.setUndoManager();\n                    this._ycellMapping.set(type, c);\n                }\n            });\n            event.changes.deleted.forEach(item => {\n                const type = item.content.type;\n                const model = this._ycellMapping.get(type);\n                if (model) {\n                    model.dispose();\n                    this._ycellMapping.delete(type);\n                }\n            });\n            let index = 0;\n            // this reflects the event.changes.delta, but replaces the content of delta.insert with ycells\n            const cellsChange = [];\n            event.changes.delta.forEach((d) => {\n                if (d.insert != null) {\n                    const insertedCells = d.insert.map((ycell) => this._ycellMapping.get(ycell));\n                    cellsChange.push({ insert: insertedCells });\n                    this.cells.splice(index, 0, ...insertedCells);\n                    index += d.insert.length;\n                }\n                else if (d.delete != null) {\n                    cellsChange.push(d);\n                    this.cells.splice(index, d.delete);\n                }\n                else if (d.retain != null) {\n                    cellsChange.push(d);\n                    index += d.retain;\n                }\n            });\n            this._changed.emit({\n                cellsChange: cellsChange\n            });\n        };\n        this._metadataChanged = new Signal(this);\n        /**\n         * Internal Yjs cells list\n         */\n        this._ycells = this.ydoc.getArray('cells');\n        this._ycellMapping = new WeakMap();\n        this._disableDocumentWideUndoRedo =\n            (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : false;\n        this.cells = this._ycells.toArray().map(ycell => {\n            if (!this._ycellMapping.has(ycell)) {\n                this._ycellMapping.set(ycell, createCellModelFromSharedType(ycell, { notebook: this }));\n            }\n            return this._ycellMapping.get(ycell);\n        });\n        this.undoManager.addToScope(this._ycells);\n        this._ycells.observe(this._onYCellsChanged);\n        this.ymeta.observe(this._onMetaChanged);\n    }\n    /**\n     * Wether the undo/redo logic should be\n     * considered on the full document across all cells.\n     *\n     * Default: false\n     */\n    get disableDocumentWideUndoRedo() {\n        return this._disableDocumentWideUndoRedo;\n    }\n    /**\n     * Notebook metadata\n     */\n    get metadata() {\n        return this.getMetadata();\n    }\n    set metadata(v) {\n        this.setMetadata(v);\n    }\n    /**\n     * Signal triggered when a metadata changes.\n     */\n    get metadataChanged() {\n        return this._metadataChanged;\n    }\n    /**\n     * nbformat major version\n     */\n    get nbformat() {\n        return this.ymeta.get('nbformat');\n    }\n    set nbformat(value) {\n        this.transact(() => {\n            this.ymeta.set('nbformat', value);\n        }, false);\n    }\n    /**\n     * nbformat minor version\n     */\n    get nbformat_minor() {\n        return this.ymeta.get('nbformat_minor');\n    }\n    set nbformat_minor(value) {\n        this.transact(() => {\n            this.ymeta.set('nbformat_minor', value);\n        }, false);\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._ycells.unobserve(this._onYCellsChanged);\n        this.ymeta.unobserve(this._onMetaChanged);\n        super.dispose();\n    }\n    /**\n     * Get a shared cell by index.\n     *\n     * @param index: Cell's position.\n     *\n     * @returns The requested shared cell.\n     */\n    getCell(index) {\n        return this.cells[index];\n    }\n    /**\n     * Add a shared cell at the notebook bottom.\n     *\n     * @param cell Cell to add.\n     *\n     * @returns The added cell.\n     */\n    addCell(cell) {\n        return this.insertCell(this._ycells.length, cell);\n    }\n    /**\n     * Insert a shared cell into a specific position.\n     *\n     * @param index: Cell's position.\n     * @param cell: Cell to insert.\n     *\n     * @returns The inserted cell.\n     */\n    insertCell(index, cell) {\n        return this.insertCells(index, [cell])[0];\n    }\n    /**\n     * Insert a list of shared cells into a specific position.\n     *\n     * @param index: Position to insert the cells.\n     * @param cells: Array of shared cells to insert.\n     *\n     * @returns The inserted cells.\n     */\n    insertCells(index, cells) {\n        const yCells = cells.map(c => {\n            const cell = createCell(c, this);\n            this._ycellMapping.set(cell.ymodel, cell);\n            return cell;\n        });\n        this.transact(() => {\n            this._ycells.insert(index, yCells.map(cell => cell.ymodel));\n        });\n        yCells.forEach(c => {\n            c.setUndoManager();\n        });\n        return yCells;\n    }\n    /**\n     * Move a cell.\n     *\n     * @param fromIndex: Index of the cell to move.\n     * @param toIndex: New position of the cell.\n     */\n    moveCell(fromIndex, toIndex) {\n        this.moveCells(fromIndex, toIndex);\n    }\n    /**\n     * Move cells.\n     *\n     * @param fromIndex: Index of the first cells to move.\n     * @param toIndex: New position of the first cell (in the current array).\n     * @param n: Number of cells to move (default 1)\n     */\n    moveCells(fromIndex, toIndex, n = 1) {\n        // FIXME we need to use yjs move feature to preserve undo history\n        const clones = new Array(n)\n            .fill(true)\n            .map((_, idx) => this.getCell(fromIndex + idx).toJSON());\n        this.transact(() => {\n            this._ycells.delete(fromIndex, n);\n            this._ycells.insert(fromIndex > toIndex ? toIndex : toIndex - n + 1, clones.map(clone => createCell(clone, this).ymodel));\n        });\n    }\n    /**\n     * Remove a cell.\n     *\n     * @param index: Index of the cell to remove.\n     */\n    deleteCell(index) {\n        this.deleteCellRange(index, index + 1);\n    }\n    /**\n     * Remove a range of cells.\n     *\n     * @param from: The start index of the range to remove (inclusive).\n     * @param to: The end index of the range to remove (exclusive).\n     */\n    deleteCellRange(from, to) {\n        // Cells will be removed from the mapping in the model event listener.\n        this.transact(() => {\n            this._ycells.delete(from, to - from);\n        });\n    }\n    /**\n     * Delete a metadata notebook.\n     *\n     * @param key The key to delete\n     */\n    deleteMetadata(key) {\n        if (typeof this.getMetadata(key) === 'undefined') {\n            return;\n        }\n        const allMetadata = JSONExt.deepCopy(this.ymeta.get('metadata'));\n        delete allMetadata[key];\n        this.setMetadata(allMetadata);\n    }\n    getMetadata(key) {\n        var _a;\n        const meta = (_a = this.ymeta.get('metadata')) !== null && _a !== void 0 ? _a : {};\n        if (typeof key === 'string') {\n            const value = meta[key];\n            return typeof value === 'undefined'\n                ? undefined // undefined is converted to `{}` by `JSONExt.deepCopy`\n                : JSONExt.deepCopy(meta[key]);\n        }\n        else {\n            return JSONExt.deepCopy(meta);\n        }\n    }\n    setMetadata(metadata, value) {\n        var _a;\n        if (typeof metadata === 'string') {\n            if (typeof value === 'undefined') {\n                throw new TypeError(`Metadata value for ${metadata} cannot be 'undefined'; use deleteMetadata.`);\n            }\n            if (JSONExt.deepEqual((_a = this.getMetadata(metadata)) !== null && _a !== void 0 ? _a : null, value)) {\n                return;\n            }\n            const update = {};\n            update[metadata] = value;\n            this.updateMetadata(update);\n        }\n        else {\n            if (!JSONExt.deepEqual(this.metadata, metadata)) {\n                this.ymeta.set('metadata', JSONExt.deepCopy(metadata));\n            }\n        }\n    }\n    /**\n     * Updates the metadata associated with the notebook.\n     *\n     * @param value: Metadata's attribute to update.\n     */\n    updateMetadata(value) {\n        // TODO: Maybe modify only attributes instead of replacing the whole metadata?\n        this.ymeta.set('metadata', { ...this.getMetadata(), ...value });\n    }\n    /**\n     * Override the notebook with a JSON-serialized document.\n     *\n     * @param value The notebook\n     */\n    fromJSON(value) {\n        this.transact(() => {\n            this.nbformat = value.nbformat;\n            this.nbformat_minor = value.nbformat_minor;\n            const metadata = value.metadata;\n            if (metadata['orig_nbformat'] !== undefined) {\n                delete metadata['orig_nbformat'];\n            }\n            this.metadata = metadata;\n            const useId = value.nbformat === 4 && value.nbformat_minor >= 5;\n            const ycells = value.cells.map(cell => {\n                if (!useId) {\n                    delete cell.id;\n                }\n                return cell;\n            });\n            this.insertCells(this.cells.length, ycells);\n            this.deleteCellRange(0, this.cells.length);\n        });\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        // strip cell ids if we have notebook format 4.0-4.4\n        const pruneCellId = this.nbformat === 4 && this.nbformat_minor <= 4;\n        return {\n            metadata: this.metadata,\n            nbformat_minor: this.nbformat_minor,\n            nbformat: this.nbformat,\n            cells: this.cells.map(c => {\n                const raw = c.toJSON();\n                if (pruneCellId) {\n                    delete raw.id;\n                }\n                return raw;\n            })\n        };\n    }\n}\n//# sourceMappingURL=ymodels.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nexport function convertYMapEventToMapChange(event) {\n    let changes = new Map();\n    event.changes.keys.forEach((event, key) => {\n        changes.set(key, {\n            action: event.action,\n            oldValue: event.oldValue,\n            newValue: this.ymeta.get(key)\n        });\n    });\n    return changes;\n}\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n */\nexport const createMutex = () => {\n    let token = true;\n    return (f) => {\n        if (token) {\n            token = false;\n            try {\n                f();\n            }\n            finally {\n                token = true;\n            }\n        }\n    };\n};\n//# sourceMappingURL=utils.js.map"],"names":["YDocument","constructor","this","ydoc","ystate","getMap","undoManager","trackedOrigins","Set","doc","awareness","onStateChanged","event","stateChange","Array","keysChanged","forEach","key","change","changes","keys","get","push","name","oldValue","newValue","_changed","emit","Signal","_isDisposed","observe","changed","isDisposed","state","JSONExt","toJSON","canUndo","undoStack","length","canRedo","redoStack","dispose","unobserve","destroy","getState","value","setState","set","undo","redo","clearUndoHistory","clear","transact","f","undoable","YFile","super","ysource","getText","_modelObserver","sourceChange","delta","addToScope","source","getSource","v","setSource","toString","ytext","delete","insert","updateSource","start","end","createCellModelFromSharedType","type","options","YCodeCell","YMarkdownCell","YRawCell","Error","createCell","cell","notebook","_a","_b","ymodel","ycell","cell_type","id","UUID","attachments","setAttachments","youtputs","cCell","execution_count","outputs","setOutputs","metadata","setMetadata","join","createStandaloneCell","YBaseCell","static","prototype","events","getChanges","_metadataChanged","_notebook","_disposed","_undoManager","_ysource","_prevSourceLength","_awareness","getArray","observeDeep","_c","disposed","getId","isStandalone","getMetadata","metadataChanged","disableDocumentWideUndoRedo","setUndoManager","unobserveDeep","deleteMetadata","allMetadata","jupyter","outputs_hidden","Object","collapsed","undefined","TypeError","clone","sourceEvent","find","target","modelEvent","has","metadataChange","oldKeys","newKeys","concat","includes","createStandalone","_youtputs","count","getOutputs","toArray","updateOutputs","fin","outputEvent","outputsChange","executionCountChange","YAttachmentCell","getAttachments","YNotebook","ymeta","_onMetaChanged","nbformatChanged","nbformat","nbformat_minor","_onYCellsChanged","added","item","content","_ycellMapping","c","deleted","model","index","cellsChange","d","insertedCells","map","cells","splice","retain","_ycells","WeakMap","_disableDocumentWideUndoRedo","getCell","addCell","insertCell","insertCells","yCells","moveCell","fromIndex","toIndex","moveCells","n","clones","fill","_","idx","deleteCell","deleteCellRange","from","to","meta","update","updateMetadata","fromJSON","useId","ycells","pruneCellId","raw","convertYMapEventToMapChange","Map","action","createMutex","token"],"sourceRoot":""}