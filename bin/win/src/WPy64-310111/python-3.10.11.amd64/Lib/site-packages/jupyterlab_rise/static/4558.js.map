{"version":3,"file":"4558.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/dialogs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/savehandler.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/widgetmanager.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/manager.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/pathstatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/savingstatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/tokens.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, showDialog, showErrorMessage } from '@jupyterlab/apputils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Widget } from '@lumino/widgets';\n/**\n * The class name added to file dialogs.\n */\nconst FILE_DIALOG_CLASS = 'jp-FileDialog';\n/**\n * The class name added for the new name label in the rename dialog\n */\nconst RENAME_NEW_NAME_TITLE_CLASS = 'jp-new-name-title';\n/**\n * Rename a file with a dialog.\n */\nexport function renameDialog(manager, oldPath, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    return showDialog({\n        title: trans.__('Rename File'),\n        body: new RenameHandler(oldPath),\n        focusNodeSelector: 'input',\n        buttons: [\n            Dialog.cancelButton({ label: trans.__('Cancel') }),\n            Dialog.okButton({ label: trans.__('Rename') })\n        ]\n    }).then(result => {\n        if (!result.value) {\n            return null;\n        }\n        if (!isValidFileName(result.value)) {\n            void showErrorMessage(trans.__('Rename Error'), Error(trans.__('\"%1\" is not a valid name for a file. Names must have nonzero length, and cannot include \"/\", \"\\\\\", or \":\"', result.value)));\n            return null;\n        }\n        const basePath = PathExt.dirname(oldPath);\n        const newPath = PathExt.join(basePath, result.value);\n        return renameFile(manager, oldPath, newPath);\n    });\n}\n/**\n * Rename a file, asking for confirmation if it is overwriting another.\n */\nexport function renameFile(manager, oldPath, newPath) {\n    return manager.rename(oldPath, newPath).catch(error => {\n        if (error.response.status !== 409) {\n            // if it's not caused by an already existing file, rethrow\n            throw error;\n        }\n        // otherwise, ask for confirmation\n        return shouldOverwrite(newPath).then((value) => {\n            if (value) {\n                return manager.overwrite(oldPath, newPath);\n            }\n            return Promise.reject('File not renamed');\n        });\n    });\n}\n/**\n * Ask the user whether to overwrite a file.\n */\nexport function shouldOverwrite(path, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    const options = {\n        title: trans.__('Overwrite file?'),\n        body: trans.__('\"%1\" already exists, overwrite?', path),\n        buttons: [\n            Dialog.cancelButton({ label: trans.__('Cancel') }),\n            Dialog.warnButton({ label: trans.__('Overwrite') })\n        ]\n    };\n    return showDialog(options).then(result => {\n        return Promise.resolve(result.button.accept);\n    });\n}\n/**\n * Test whether a name is a valid file name\n *\n * Disallows \"/\", \"\\\", and \":\" in file names, as well as names with zero length.\n */\nexport function isValidFileName(name) {\n    const validNameExp = /[\\/\\\\:]/;\n    return name.length > 0 && !validNameExp.test(name);\n}\n/**\n * A widget used to rename a file.\n */\nclass RenameHandler extends Widget {\n    /**\n     * Construct a new \"rename\" dialog.\n     */\n    constructor(oldPath) {\n        super({ node: Private.createRenameNode(oldPath) });\n        this.addClass(FILE_DIALOG_CLASS);\n        const ext = PathExt.extname(oldPath);\n        const value = (this.inputNode.value = PathExt.basename(oldPath));\n        this.inputNode.setSelectionRange(0, value.length - ext.length);\n    }\n    /**\n     * Get the input text node.\n     */\n    get inputNode() {\n        return this.node.getElementsByTagName('input')[0];\n    }\n    /**\n     * Get the value of the widget.\n     */\n    getValue() {\n        return this.inputNode.value;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Create the node for a rename handler.\n     */\n    function createRenameNode(oldPath, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        const body = document.createElement('div');\n        const existingLabel = document.createElement('label');\n        existingLabel.textContent = trans.__('File Path');\n        const existingPath = document.createElement('span');\n        existingPath.textContent = oldPath;\n        const nameTitle = document.createElement('label');\n        nameTitle.textContent = trans.__('New Name');\n        nameTitle.className = RENAME_NEW_NAME_TITLE_CLASS;\n        const name = document.createElement('input');\n        body.appendChild(existingLabel);\n        body.appendChild(existingPath);\n        body.appendChild(nameTitle);\n        body.appendChild(name);\n        return body;\n    }\n    Private.createRenameNode = createRenameNode;\n})(Private || (Private = {}));\n//# sourceMappingURL=dialogs.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\n/**\n * A class that manages the auto saving of a document.\n *\n * #### Notes\n * Implements https://github.com/ipython/ipython/wiki/IPEP-15:-Autosaving-the-IPython-Notebook.\n */\nexport class SaveHandler {\n    /**\n     * Construct a new save handler.\n     */\n    constructor(options) {\n        this._autosaveTimer = -1;\n        this._minInterval = -1;\n        this._interval = -1;\n        this._isActive = false;\n        this._inDialog = false;\n        this._isDisposed = false;\n        this._multiplier = 10;\n        this._context = options.context;\n        const interval = options.saveInterval || 120;\n        this._minInterval = interval * 1000;\n        this._interval = this._minInterval;\n        // Restart the timer when the contents model is updated.\n        this._context.fileChanged.connect(this._setTimer, this);\n        this._context.disposed.connect(this.dispose, this);\n    }\n    /**\n     * The save interval used by the timer (in seconds).\n     */\n    get saveInterval() {\n        return this._interval / 1000;\n    }\n    set saveInterval(value) {\n        this._minInterval = this._interval = value * 1000;\n        if (this._isActive) {\n            this._setTimer();\n        }\n    }\n    /**\n     * Get whether the handler is active.\n     */\n    get isActive() {\n        return this._isActive;\n    }\n    /**\n     * Get whether the save handler is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the save handler.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        clearTimeout(this._autosaveTimer);\n        Signal.clearData(this);\n    }\n    /**\n     * Start the autosaver.\n     */\n    start() {\n        this._isActive = true;\n        this._setTimer();\n    }\n    /**\n     * Stop the autosaver.\n     */\n    stop() {\n        this._isActive = false;\n        clearTimeout(this._autosaveTimer);\n    }\n    /**\n     * Set the timer.\n     */\n    _setTimer() {\n        clearTimeout(this._autosaveTimer);\n        if (!this._isActive) {\n            return;\n        }\n        this._autosaveTimer = window.setTimeout(() => {\n            this._save();\n        }, this._interval);\n    }\n    /**\n     * Handle an autosave timeout.\n     */\n    _save() {\n        const context = this._context;\n        // Trigger the next update.\n        this._setTimer();\n        if (!context) {\n            return;\n        }\n        // Bail if the model is not dirty or the file is not writable, or the dialog\n        // is already showing.\n        const writable = context.contentsModel && context.contentsModel.writable;\n        if (!writable || !context.model.dirty || this._inDialog) {\n            return;\n        }\n        const start = new Date().getTime();\n        context\n            .save()\n            .then(() => {\n            if (this.isDisposed) {\n                return;\n            }\n            const duration = new Date().getTime() - start;\n            // New save interval: higher of 10x save duration or min interval.\n            this._interval = Math.max(this._multiplier * duration, this._minInterval);\n            // Restart the update to pick up the new interval.\n            this._setTimer();\n        })\n            .catch(err => {\n            // If the user canceled the save, do nothing.\n            // FIXME-TRANS: Is this affected by localization?\n            if (err.message === 'Cancel' ||\n                err.message === 'Modal is already displayed') {\n                return;\n            }\n            // Otherwise, log the error.\n            console.error('Error in Auto-Save', err.message);\n        });\n    }\n}\n//# sourceMappingURL=savehandler.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { Time } from '@jupyterlab/coreutils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt, each, filter, find, map, toArray } from '@lumino/algorithm';\nimport { DisposableSet } from '@lumino/disposable';\nimport { MessageLoop } from '@lumino/messaging';\nimport { AttachedProperty } from '@lumino/properties';\nimport { Signal } from '@lumino/signaling';\n/**\n * The class name added to document widgets.\n */\nconst DOCUMENT_CLASS = 'jp-Document';\n/**\n * A class that maintains the lifecycle of file-backed widgets.\n */\nexport class DocumentWidgetManager {\n    /**\n     * Construct a new document widget manager.\n     */\n    constructor(options) {\n        this._activateRequested = new Signal(this);\n        this._confirmClosingTab = false;\n        this._isDisposed = false;\n        this._stateChanged = new Signal(this);\n        this._registry = options.registry;\n        this.translator = options.translator || nullTranslator;\n    }\n    /**\n     * A signal emitted when one of the documents is activated.\n     */\n    get activateRequested() {\n        return this._activateRequested;\n    }\n    /**\n     * Whether to ask confirmation to close a tab or not.\n     */\n    get confirmClosingDocument() {\n        return this._confirmClosingTab;\n    }\n    set confirmClosingDocument(v) {\n        if (this._confirmClosingTab !== v) {\n            const oldValue = this._confirmClosingTab;\n            this._confirmClosingTab = v;\n            this._stateChanged.emit({\n                name: 'confirmClosingDocument',\n                oldValue,\n                newValue: v\n            });\n        }\n    }\n    /**\n     * Signal triggered when an attribute changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * Test whether the document widget manager is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the widget manager.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.disconnectReceiver(this);\n    }\n    /**\n     * Create a widget for a document and handle its lifecycle.\n     *\n     * @param factory - The widget factory.\n     *\n     * @param context - The document context object.\n     *\n     * @returns A widget created by the factory.\n     *\n     * @throws If the factory is not registered.\n     */\n    createWidget(factory, context) {\n        const widget = factory.createNew(context);\n        this._initializeWidget(widget, factory, context);\n        return widget;\n    }\n    /**\n     * When a new widget is created, we need to hook it up\n     * with some signals, update the widget extensions (for\n     * this kind of widget) in the docregistry, among\n     * other things.\n     */\n    _initializeWidget(widget, factory, context) {\n        Private.factoryProperty.set(widget, factory);\n        // Handle widget extensions.\n        const disposables = new DisposableSet();\n        each(this._registry.widgetExtensions(factory.name), extender => {\n            const disposable = extender.createNew(widget, context);\n            if (disposable) {\n                disposables.add(disposable);\n            }\n        });\n        Private.disposablesProperty.set(widget, disposables);\n        widget.disposed.connect(this._onWidgetDisposed, this);\n        this.adoptWidget(context, widget);\n        context.fileChanged.connect(this._onFileChanged, this);\n        context.pathChanged.connect(this._onPathChanged, this);\n        void context.ready.then(() => {\n            void this.setCaption(widget);\n        });\n    }\n    /**\n     * Install the message hook for the widget and add to list\n     * of known widgets.\n     *\n     * @param context - The document context object.\n     *\n     * @param widget - The widget to adopt.\n     */\n    adoptWidget(context, widget) {\n        const widgets = Private.widgetsProperty.get(context);\n        widgets.push(widget);\n        MessageLoop.installMessageHook(widget, this);\n        widget.addClass(DOCUMENT_CLASS);\n        widget.title.closable = true;\n        widget.disposed.connect(this._widgetDisposed, this);\n        Private.contextProperty.set(widget, context);\n    }\n    /**\n     * See if a widget already exists for the given context and widget name.\n     *\n     * @param context - The document context object.\n     *\n     * @returns The found widget, or `undefined`.\n     *\n     * #### Notes\n     * This can be used to use an existing widget instead of opening\n     * a new widget.\n     */\n    findWidget(context, widgetName) {\n        const widgets = Private.widgetsProperty.get(context);\n        if (!widgets) {\n            return undefined;\n        }\n        return find(widgets, widget => {\n            const factory = Private.factoryProperty.get(widget);\n            if (!factory) {\n                return false;\n            }\n            return factory.name === widgetName;\n        });\n    }\n    /**\n     * Get the document context for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The context associated with the widget, or `undefined`.\n     */\n    contextForWidget(widget) {\n        return Private.contextProperty.get(widget);\n    }\n    /**\n     * Clone a widget.\n     *\n     * @param widget - The source widget.\n     *\n     * @returns A new widget or `undefined`.\n     *\n     * #### Notes\n     *  Uses the same widget factory and context as the source, or throws\n     *  if the source widget is not managed by this manager.\n     */\n    cloneWidget(widget) {\n        const context = Private.contextProperty.get(widget);\n        if (!context) {\n            return undefined;\n        }\n        const factory = Private.factoryProperty.get(widget);\n        if (!factory) {\n            return undefined;\n        }\n        const newWidget = factory.createNew(context, widget);\n        this._initializeWidget(newWidget, factory, context);\n        return newWidget;\n    }\n    /**\n     * Close the widgets associated with a given context.\n     *\n     * @param context - The document context object.\n     */\n    closeWidgets(context) {\n        const widgets = Private.widgetsProperty.get(context);\n        return Promise.all(toArray(map(widgets, widget => this.onClose(widget)))).then(() => undefined);\n    }\n    /**\n     * Dispose of the widgets associated with a given context\n     * regardless of the widget's dirty state.\n     *\n     * @param context - The document context object.\n     */\n    deleteWidgets(context) {\n        const widgets = Private.widgetsProperty.get(context);\n        return Promise.all(toArray(map(widgets, widget => this.onDelete(widget)))).then(() => undefined);\n    }\n    /**\n     * Filter a message sent to a message handler.\n     *\n     * @param handler - The target handler of the message.\n     *\n     * @param msg - The message dispatched to the handler.\n     *\n     * @returns `false` if the message should be filtered, of `true`\n     *   if the message should be dispatched to the handler as normal.\n     */\n    messageHook(handler, msg) {\n        switch (msg.type) {\n            case 'close-request':\n                void this.onClose(handler);\n                return false;\n            case 'activate-request': {\n                const context = this.contextForWidget(handler);\n                if (context) {\n                    this._activateRequested.emit(context.path);\n                }\n                break;\n            }\n            default:\n                break;\n        }\n        return true;\n    }\n    /**\n     * Set the caption for widget title.\n     *\n     * @param widget - The target widget.\n     */\n    async setCaption(widget) {\n        const trans = this.translator.load('jupyterlab');\n        const context = Private.contextProperty.get(widget);\n        if (!context) {\n            return;\n        }\n        const model = context.contentsModel;\n        if (!model) {\n            widget.title.caption = '';\n            return;\n        }\n        return context\n            .listCheckpoints()\n            .then((checkpoints) => {\n            if (widget.isDisposed) {\n                return;\n            }\n            const last = checkpoints[checkpoints.length - 1];\n            const checkpoint = last ? Time.format(last.last_modified) : 'None';\n            let caption = trans.__('Name: %1\\nPath: %2\\n', model.name, model.path);\n            if (context.model.readOnly) {\n                caption += trans.__('Read-only');\n            }\n            else {\n                caption +=\n                    trans.__('Last Saved: %1\\n', Time.format(model.last_modified)) +\n                        trans.__('Last Checkpoint: %1', checkpoint);\n            }\n            widget.title.caption = caption;\n        });\n    }\n    /**\n     * Handle `'close-request'` messages.\n     *\n     * @param widget - The target widget.\n     *\n     * @returns A promise that resolves with whether the widget was closed.\n     */\n    async onClose(widget) {\n        var _a;\n        // Handle dirty state.\n        const [shouldClose, ignoreSave] = await this._maybeClose(widget, this.translator);\n        if (widget.isDisposed) {\n            return true;\n        }\n        if (shouldClose) {\n            if (!ignoreSave) {\n                const context = Private.contextProperty.get(widget);\n                if (!context) {\n                    return true;\n                }\n                if ((_a = context.contentsModel) === null || _a === void 0 ? void 0 : _a.writable) {\n                    await context.save();\n                }\n                else {\n                    await context.saveAs();\n                }\n            }\n            if (widget.isDisposed) {\n                return true;\n            }\n            widget.dispose();\n        }\n        return shouldClose;\n    }\n    /**\n     * Dispose of widget regardless of widget's dirty state.\n     *\n     * @param widget - The target widget.\n     */\n    onDelete(widget) {\n        widget.dispose();\n        return Promise.resolve(void 0);\n    }\n    /**\n     * Ask the user whether to close an unsaved file.\n     */\n    async _maybeClose(widget, translator) {\n        var _a, _b;\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        // Bail if the model is not dirty or other widgets are using the model.)\n        const context = Private.contextProperty.get(widget);\n        if (!context) {\n            return Promise.resolve([true, true]);\n        }\n        let widgets = Private.widgetsProperty.get(context);\n        if (!widgets) {\n            return Promise.resolve([true, true]);\n        }\n        // Filter by whether the factories are read only.\n        widgets = toArray(filter(widgets, widget => {\n            const factory = Private.factoryProperty.get(widget);\n            if (!factory) {\n                return false;\n            }\n            return factory.readOnly === false;\n        }));\n        const fileName = widget.title.label;\n        const factory = Private.factoryProperty.get(widget);\n        const isDirty = context.model.dirty &&\n            widgets.length <= 1 &&\n            !((_a = factory === null || factory === void 0 ? void 0 : factory.readOnly) !== null && _a !== void 0 ? _a : true);\n        // Ask confirmation\n        if (this.confirmClosingDocument) {\n            const buttons = [\n                Dialog.cancelButton(),\n                Dialog.okButton({\n                    label: isDirty ? trans.__('Close and save') : trans.__('Close')\n                })\n            ];\n            if (isDirty) {\n                buttons.splice(1, 0, Dialog.warnButton({ label: trans.__('Close without saving') }));\n            }\n            const confirm = await showDialog({\n                title: trans.__('Confirmation'),\n                body: trans.__('Please confirm you want to close \"%1\".', fileName),\n                checkbox: isDirty\n                    ? null\n                    : {\n                        label: trans.__('Do not ask me again.'),\n                        caption: trans.__('If checked, no confirmation to close a document will be asked in the future.')\n                    },\n                buttons\n            });\n            if (confirm.isChecked) {\n                this.confirmClosingDocument = false;\n            }\n            return Promise.resolve([\n                confirm.button.accept,\n                isDirty ? confirm.button.displayType === 'warn' : true\n            ]);\n        }\n        else {\n            if (!isDirty) {\n                return Promise.resolve([true, true]);\n            }\n            const saveLabel = ((_b = context.contentsModel) === null || _b === void 0 ? void 0 : _b.writable) ? trans.__('Save')\n                : trans.__('Save as');\n            const result = await showDialog({\n                title: trans.__('Save your work'),\n                body: trans.__('Save changes in \"%1\" before closing?', fileName),\n                buttons: [\n                    Dialog.cancelButton({ label: trans.__('Cancel') }),\n                    Dialog.warnButton({ label: trans.__('Discard') }),\n                    Dialog.okButton({ label: saveLabel })\n                ]\n            });\n            return [result.button.accept, result.button.displayType === 'warn'];\n        }\n    }\n    /**\n     * Handle the disposal of a widget.\n     */\n    _widgetDisposed(widget) {\n        const context = Private.contextProperty.get(widget);\n        if (!context) {\n            return;\n        }\n        const widgets = Private.widgetsProperty.get(context);\n        if (!widgets) {\n            return;\n        }\n        // Remove the widget.\n        ArrayExt.removeFirstOf(widgets, widget);\n        // Dispose of the context if this is the last widget using it.\n        if (!widgets.length) {\n            context.dispose();\n        }\n    }\n    /**\n     * Handle the disposal of a widget.\n     */\n    _onWidgetDisposed(widget) {\n        const disposables = Private.disposablesProperty.get(widget);\n        disposables.dispose();\n    }\n    /**\n     * Handle a file changed signal for a context.\n     */\n    _onFileChanged(context) {\n        const widgets = Private.widgetsProperty.get(context);\n        each(widgets, widget => {\n            void this.setCaption(widget);\n        });\n    }\n    /**\n     * Handle a path changed signal for a context.\n     */\n    _onPathChanged(context) {\n        const widgets = Private.widgetsProperty.get(context);\n        each(widgets, widget => {\n            void this.setCaption(widget);\n        });\n    }\n}\n/**\n * A private namespace for DocumentManager data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A private attached property for a widget context.\n     */\n    Private.contextProperty = new AttachedProperty({\n        name: 'context',\n        create: () => undefined\n    });\n    /**\n     * A private attached property for a widget factory.\n     */\n    Private.factoryProperty = new AttachedProperty({\n        name: 'factory',\n        create: () => undefined\n    });\n    /**\n     * A private attached property for the widgets associated with a context.\n     */\n    Private.widgetsProperty = new AttachedProperty({\n        name: 'widgets',\n        create: () => []\n    });\n    /**\n     * A private attached property for a widget's disposables.\n     */\n    Private.disposablesProperty = new AttachedProperty({\n        name: 'disposables',\n        create: () => new DisposableSet()\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=widgetmanager.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { sessionContextDialogs } from '@jupyterlab/apputils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { Context } from '@jupyterlab/docregistry';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt, find } from '@lumino/algorithm';\nimport { UUID } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\nimport { Signal } from '@lumino/signaling';\nimport { SaveHandler } from './savehandler';\nimport { DocumentWidgetManager } from './widgetmanager';\n/**\n * The document manager.\n *\n * #### Notes\n * The document manager is used to register model and widget creators,\n * and the file browser uses the document manager to create widgets. The\n * document manager maintains a context for each path and model type that is\n * open, and a list of widgets for each context. The document manager is in\n * control of the proper closing and disposal of the widgets and contexts.\n */\nexport class DocumentManager {\n    /**\n     * Construct a new document manager.\n     */\n    constructor(options) {\n        this._activateRequested = new Signal(this);\n        this._contexts = [];\n        this._isDisposed = false;\n        this._autosave = true;\n        this._autosaveInterval = 120;\n        this._lastModifiedCheckMargin = 500;\n        this._renameUntitledFileOnSave = true;\n        this._stateChanged = new Signal(this);\n        this.translator = options.translator || nullTranslator;\n        this.registry = options.registry;\n        this.services = options.manager;\n        this._dialogs = options.sessionDialogs || sessionContextDialogs;\n        this._docProviderFactory = options.docProviderFactory;\n        this._opener = options.opener;\n        this._when = options.when || options.manager.ready;\n        const widgetManager = new DocumentWidgetManager({\n            registry: this.registry,\n            translator: this.translator\n        });\n        widgetManager.activateRequested.connect(this._onActivateRequested, this);\n        widgetManager.stateChanged.connect(this._onWidgetStateChanged, this);\n        this._widgetManager = widgetManager;\n        this._setBusy = options.setBusy;\n    }\n    /**\n     * A signal emitted when one of the documents is activated.\n     */\n    get activateRequested() {\n        return this._activateRequested;\n    }\n    /**\n     * Whether to autosave documents.\n     */\n    get autosave() {\n        return this._autosave;\n    }\n    set autosave(value) {\n        if (this._autosave !== value) {\n            const oldValue = this._autosave;\n            this._autosave = value;\n            // For each existing context, start/stop the autosave handler as needed.\n            this._contexts.forEach(context => {\n                const handler = Private.saveHandlerProperty.get(context);\n                if (!handler) {\n                    return;\n                }\n                if (value === true && !handler.isActive) {\n                    handler.start();\n                }\n                else if (value === false && handler.isActive) {\n                    handler.stop();\n                }\n            });\n            this._stateChanged.emit({\n                name: 'autosave',\n                oldValue,\n                newValue: value\n            });\n        }\n    }\n    /**\n     * Determines the time interval for autosave in seconds.\n     */\n    get autosaveInterval() {\n        return this._autosaveInterval;\n    }\n    set autosaveInterval(value) {\n        if (this._autosaveInterval !== value) {\n            const oldValue = this._autosaveInterval;\n            this._autosaveInterval = value;\n            // For each existing context, set the save interval as needed.\n            this._contexts.forEach(context => {\n                const handler = Private.saveHandlerProperty.get(context);\n                if (!handler) {\n                    return;\n                }\n                handler.saveInterval = value || 120;\n            });\n            this._stateChanged.emit({\n                name: 'autosaveInterval',\n                oldValue,\n                newValue: value\n            });\n        }\n    }\n    /**\n     * Whether to ask confirmation to close a tab or not.\n     */\n    get confirmClosingDocument() {\n        return this._widgetManager.confirmClosingDocument;\n    }\n    set confirmClosingDocument(value) {\n        if (this._widgetManager.confirmClosingDocument !== value) {\n            const oldValue = this._widgetManager.confirmClosingDocument;\n            this._widgetManager.confirmClosingDocument = value;\n            this._stateChanged.emit({\n                name: 'confirmClosingDocument',\n                oldValue,\n                newValue: value\n            });\n        }\n    }\n    /**\n     * Defines max acceptable difference, in milliseconds, between last modified timestamps on disk and client\n     */\n    get lastModifiedCheckMargin() {\n        return this._lastModifiedCheckMargin;\n    }\n    set lastModifiedCheckMargin(value) {\n        if (this._lastModifiedCheckMargin !== value) {\n            const oldValue = this._lastModifiedCheckMargin;\n            this._lastModifiedCheckMargin = value;\n            // For each existing context, update the margin value.\n            this._contexts.forEach(context => {\n                context.lastModifiedCheckMargin = value;\n            });\n            this._stateChanged.emit({\n                name: 'lastModifiedCheckMargin',\n                oldValue,\n                newValue: value\n            });\n        }\n    }\n    /**\n     * Whether to ask the user to rename untitled file on first manual save.\n     */\n    get renameUntitledFileOnSave() {\n        return this._renameUntitledFileOnSave;\n    }\n    set renameUntitledFileOnSave(value) {\n        if (this._renameUntitledFileOnSave !== value) {\n            const oldValue = this._renameUntitledFileOnSave;\n            this._renameUntitledFileOnSave = value;\n            this._stateChanged.emit({\n                name: 'renameUntitledFileOnSave',\n                oldValue,\n                newValue: value\n            });\n        }\n    }\n    /**\n     * Signal triggered when an attribute changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * Get whether the document manager has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the document manager.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        // Clear any listeners for our signals.\n        Signal.clearData(this);\n        // Close all the widgets for our contexts and dispose the widget manager.\n        this._contexts.forEach(context => {\n            return this._widgetManager.closeWidgets(context);\n        });\n        this._widgetManager.dispose();\n        // Clear the context list.\n        this._contexts.length = 0;\n    }\n    /**\n     * Clone a widget.\n     *\n     * @param widget - The source widget.\n     *\n     * @returns A new widget or `undefined`.\n     *\n     * #### Notes\n     *  Uses the same widget factory and context as the source, or returns\n     *  `undefined` if the source widget is not managed by this manager.\n     */\n    cloneWidget(widget) {\n        return this._widgetManager.cloneWidget(widget);\n    }\n    /**\n     * Close all of the open documents.\n     *\n     * @returns A promise resolving when the widgets are closed.\n     */\n    closeAll() {\n        return Promise.all(this._contexts.map(context => this._widgetManager.closeWidgets(context))).then(() => undefined);\n    }\n    /**\n     * Close the widgets associated with a given path.\n     *\n     * @param path - The target path.\n     *\n     * @returns A promise resolving when the widgets are closed.\n     */\n    closeFile(path) {\n        const close = this._contextsForPath(path).map(c => this._widgetManager.closeWidgets(c));\n        return Promise.all(close).then(x => undefined);\n    }\n    /**\n     * Get the document context for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The context associated with the widget, or `undefined` if no such\n     * context exists.\n     */\n    contextForWidget(widget) {\n        return this._widgetManager.contextForWidget(widget);\n    }\n    /**\n     * Copy a file.\n     *\n     * @param fromFile - The full path of the original file.\n     *\n     * @param toDir - The full path to the target directory.\n     *\n     * @returns A promise which resolves to the contents of the file.\n     */\n    copy(fromFile, toDir) {\n        return this.services.contents.copy(fromFile, toDir);\n    }\n    /**\n     * Create a new file and return the widget used to view it.\n     *\n     * @param path - The file path to create.\n     *\n     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n     *\n     * @param kernel - An optional kernel name/id to override the default.\n     *\n     * @returns The created widget, or `undefined`.\n     *\n     * #### Notes\n     * This function will return `undefined` if a valid widget factory\n     * cannot be found.\n     */\n    createNew(path, widgetName = 'default', kernel) {\n        return this._createOrOpenDocument('create', path, widgetName, kernel);\n    }\n    /**\n     * Delete a file.\n     *\n     * @param path - The full path to the file to be deleted.\n     *\n     * @returns A promise which resolves when the file is deleted.\n     *\n     * #### Notes\n     * If there is a running session associated with the file and no other\n     * sessions are using the kernel, the session will be shut down.\n     */\n    deleteFile(path) {\n        return this.services.sessions\n            .stopIfNeeded(path)\n            .then(() => {\n            return this.services.contents.delete(path);\n        })\n            .then(() => {\n            this._contextsForPath(path).forEach(context => this._widgetManager.deleteWidgets(context));\n            return Promise.resolve(void 0);\n        });\n    }\n    /**\n     * See if a widget already exists for the given path and widget name.\n     *\n     * @param path - The file path to use.\n     *\n     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n     *\n     * @returns The found widget, or `undefined`.\n     *\n     * #### Notes\n     * This can be used to find an existing widget instead of opening\n     * a new widget.\n     */\n    findWidget(path, widgetName = 'default') {\n        const newPath = PathExt.normalize(path);\n        let widgetNames = [widgetName];\n        if (widgetName === 'default') {\n            const factory = this.registry.defaultWidgetFactory(newPath);\n            if (!factory) {\n                return undefined;\n            }\n            widgetNames = [factory.name];\n        }\n        else if (widgetName === null) {\n            widgetNames = this.registry\n                .preferredWidgetFactories(newPath)\n                .map(f => f.name);\n        }\n        for (const context of this._contextsForPath(newPath)) {\n            for (const widgetName of widgetNames) {\n                if (widgetName !== null) {\n                    const widget = this._widgetManager.findWidget(context, widgetName);\n                    if (widget) {\n                        return widget;\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Create a new untitled file.\n     *\n     * @param options - The file content creation options.\n     */\n    newUntitled(options) {\n        if (options.type === 'file') {\n            options.ext = options.ext || '.txt';\n        }\n        return this.services.contents.newUntitled(options);\n    }\n    /**\n     * Open a file and return the widget used to view it.\n     *\n     * @param path - The file path to open.\n     *\n     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n     *\n     * @param kernel - An optional kernel name/id to override the default.\n     *\n     * @returns The created widget, or `undefined`.\n     *\n     * #### Notes\n     * This function will return `undefined` if a valid widget factory\n     * cannot be found.\n     */\n    open(path, widgetName = 'default', kernel, options) {\n        return this._createOrOpenDocument('open', path, widgetName, kernel, options);\n    }\n    /**\n     * Open a file and return the widget used to view it.\n     * Reveals an already existing editor.\n     *\n     * @param path - The file path to open.\n     *\n     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n     *\n     * @param kernel - An optional kernel name/id to override the default.\n     *\n     * @returns The created widget, or `undefined`.\n     *\n     * #### Notes\n     * This function will return `undefined` if a valid widget factory\n     * cannot be found.\n     */\n    openOrReveal(path, widgetName = 'default', kernel, options) {\n        const widget = this.findWidget(path, widgetName);\n        if (widget) {\n            this._opener.open(widget, options || {});\n            return widget;\n        }\n        return this.open(path, widgetName, kernel, options || {});\n    }\n    /**\n     * Overwrite a file.\n     *\n     * @param oldPath - The full path to the original file.\n     *\n     * @param newPath - The full path to the new file.\n     *\n     * @returns A promise containing the new file contents model.\n     */\n    overwrite(oldPath, newPath) {\n        // Cleanly overwrite the file by moving it, making sure the original does\n        // not exist, and then renaming to the new path.\n        const tempPath = `${newPath}.${UUID.uuid4()}`;\n        const cb = () => this.rename(tempPath, newPath);\n        return this.rename(oldPath, tempPath)\n            .then(() => {\n            return this.deleteFile(newPath);\n        })\n            .then(cb, cb);\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldPath - The full path to the original file.\n     *\n     * @param newPath - The full path to the new file.\n     *\n     * @returns A promise containing the new file contents model.  The promise\n     * will reject if the newPath already exists.  Use [[overwrite]] to overwrite\n     * a file.\n     */\n    rename(oldPath, newPath) {\n        return this.services.contents.rename(oldPath, newPath);\n    }\n    /**\n     * Find a context for a given path and factory name.\n     */\n    _findContext(path, factoryName) {\n        const normalizedPath = this.services.contents.normalize(path);\n        return find(this._contexts, context => {\n            return (context.path === normalizedPath && context.factoryName === factoryName);\n        });\n    }\n    /**\n     * Get the contexts for a given path.\n     *\n     * #### Notes\n     * There may be more than one context for a given path if the path is open\n     * with multiple model factories (for example, a notebook can be open with a\n     * notebook model factory and a text model factory).\n     */\n    _contextsForPath(path) {\n        const normalizedPath = this.services.contents.normalize(path);\n        return this._contexts.filter(context => context.path === normalizedPath);\n    }\n    /**\n     * Create a context from a path and a model factory.\n     */\n    _createContext(path, factory, kernelPreference) {\n        // TODO: Make it impossible to open two different contexts for the same\n        // path. Or at least prompt the closing of all widgets associated with the\n        // old context before opening the new context. This will make things much\n        // more consistent for the users, at the cost of some confusion about what\n        // models are and why sometimes they cannot open the same file in different\n        // widgets that have different models.\n        // Allow options to be passed when adding a sibling.\n        const adopter = (widget, options) => {\n            this._widgetManager.adoptWidget(context, widget);\n            this._opener.open(widget, options);\n        };\n        const modelDBFactory = this.services.contents.getModelDBFactory(path) || undefined;\n        const context = new Context({\n            opener: adopter,\n            manager: this.services,\n            factory,\n            path,\n            kernelPreference,\n            modelDBFactory,\n            setBusy: this._setBusy,\n            sessionDialogs: this._dialogs,\n            docProviderFactory: this._docProviderFactory,\n            lastModifiedCheckMargin: this._lastModifiedCheckMargin,\n            translator: this.translator\n        });\n        const handler = new SaveHandler({\n            context,\n            saveInterval: this.autosaveInterval\n        });\n        Private.saveHandlerProperty.set(context, handler);\n        void context.ready.then(() => {\n            if (this.autosave) {\n                handler.start();\n            }\n        });\n        context.disposed.connect(this._onContextDisposed, this);\n        this._contexts.push(context);\n        return context;\n    }\n    /**\n     * Handle a context disposal.\n     */\n    _onContextDisposed(context) {\n        ArrayExt.removeFirstOf(this._contexts, context);\n    }\n    /**\n     * Get the widget factory for a given widget name.\n     */\n    _widgetFactoryFor(path, widgetName) {\n        const { registry } = this;\n        if (widgetName === 'default') {\n            const factory = registry.defaultWidgetFactory(path);\n            if (!factory) {\n                return undefined;\n            }\n            widgetName = factory.name;\n        }\n        return registry.getWidgetFactory(widgetName);\n    }\n    /**\n     * Creates a new document, or loads one from disk, depending on the `which` argument.\n     * If `which==='create'`, then it creates a new document. If `which==='open'`,\n     * then it loads the document from disk.\n     *\n     * The two cases differ in how the document context is handled, but the creation\n     * of the widget and launching of the kernel are identical.\n     */\n    _createOrOpenDocument(which, path, widgetName = 'default', kernel, options) {\n        const widgetFactory = this._widgetFactoryFor(path, widgetName);\n        if (!widgetFactory) {\n            return undefined;\n        }\n        const modelName = widgetFactory.modelName || 'text';\n        const factory = this.registry.getModelFactory(modelName);\n        if (!factory) {\n            return undefined;\n        }\n        // Handle the kernel preference.\n        const preference = this.registry.getKernelPreference(path, widgetFactory.name, kernel);\n        let context;\n        let ready = Promise.resolve(undefined);\n        // Handle the load-from-disk case\n        if (which === 'open') {\n            // Use an existing context if available.\n            context = this._findContext(path, factory.name) || null;\n            if (!context) {\n                context = this._createContext(path, factory, preference);\n                // Populate the model, either from disk or a\n                // model backend.\n                ready = this._when.then(() => context.initialize(false));\n            }\n        }\n        else if (which === 'create') {\n            context = this._createContext(path, factory, preference);\n            // Immediately save the contents to disk.\n            ready = this._when.then(() => context.initialize(true));\n        }\n        else {\n            throw new Error(`Invalid argument 'which': ${which}`);\n        }\n        const widget = this._widgetManager.createWidget(widgetFactory, context);\n        this._opener.open(widget, options || {});\n        // If the initial opening of the context fails, dispose of the widget.\n        ready.catch(err => {\n            console.error(`Failed to initialize the context with '${factory.name}' for ${path}`, err);\n            widget.close();\n        });\n        return widget;\n    }\n    /**\n     * Handle an activateRequested signal from the widget manager.\n     */\n    _onActivateRequested(sender, args) {\n        this._activateRequested.emit(args);\n    }\n    _onWidgetStateChanged(sender, args) {\n        if (args.name === 'confirmClosingDocument') {\n            this._stateChanged.emit(args);\n        }\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for a context save handler.\n     */\n    Private.saveHandlerProperty = new AttachedProperty({\n        name: 'saveHandler',\n        create: () => undefined\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=manager.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { VDomModel, VDomRenderer } from '@jupyterlab/apputils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { TextItem } from '@jupyterlab/statusbar';\nimport React from 'react';\n/**\n * A pure component for rendering a file path (or activity name).\n *\n * @param props - the props for the component.\n *\n * @returns a tsx component for a file path.\n */\nfunction PathStatusComponent(props) {\n    return React.createElement(TextItem, { source: props.name, title: props.fullPath });\n}\n/**\n * A status bar item for the current file path (or activity name).\n */\nexport class PathStatus extends VDomRenderer {\n    /**\n     * Construct a new PathStatus status item.\n     */\n    constructor(opts) {\n        super(new PathStatus.Model(opts.docManager));\n        this.node.title = this.model.path;\n    }\n    /**\n     * Render the status item.\n     */\n    render() {\n        return (React.createElement(PathStatusComponent, { fullPath: this.model.path, name: this.model.name }));\n    }\n}\n/**\n * A namespace for PathStatus statics.\n */\n(function (PathStatus) {\n    /**\n     * A VDomModel for rendering the PathStatus status item.\n     */\n    class Model extends VDomModel {\n        /**\n         * Construct a new model.\n         *\n         * @param docManager: the application document manager. Used to check\n         *   whether the current widget is a document.\n         */\n        constructor(docManager) {\n            super();\n            /**\n             * React to a title change for the current widget.\n             */\n            this._onTitleChange = (title) => {\n                const oldState = this._getAllState();\n                this._name = title.label;\n                this._triggerChange(oldState, this._getAllState());\n            };\n            /**\n             * React to a path change for the current document.\n             */\n            this._onPathChange = (_documentModel, newPath) => {\n                const oldState = this._getAllState();\n                this._path = newPath;\n                this._name = PathExt.basename(newPath);\n                this._triggerChange(oldState, this._getAllState());\n            };\n            this._path = '';\n            this._name = '';\n            this._widget = null;\n            this._docManager = docManager;\n        }\n        /**\n         * The current path for the application.\n         */\n        get path() {\n            return this._path;\n        }\n        /**\n         * The name of the current activity.\n         */\n        get name() {\n            return this._name;\n        }\n        /**\n         * The current widget for the application.\n         */\n        get widget() {\n            return this._widget;\n        }\n        set widget(widget) {\n            const oldWidget = this._widget;\n            if (oldWidget !== null) {\n                const oldContext = this._docManager.contextForWidget(oldWidget);\n                if (oldContext) {\n                    oldContext.pathChanged.disconnect(this._onPathChange);\n                }\n                else {\n                    oldWidget.title.changed.disconnect(this._onTitleChange);\n                }\n            }\n            const oldState = this._getAllState();\n            this._widget = widget;\n            if (this._widget === null) {\n                this._path = '';\n                this._name = '';\n            }\n            else {\n                const widgetContext = this._docManager.contextForWidget(this._widget);\n                if (widgetContext) {\n                    this._path = widgetContext.path;\n                    this._name = PathExt.basename(widgetContext.path);\n                    widgetContext.pathChanged.connect(this._onPathChange);\n                }\n                else {\n                    this._path = '';\n                    this._name = this._widget.title.label;\n                    this._widget.title.changed.connect(this._onTitleChange);\n                }\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * Get the current state of the model.\n         */\n        _getAllState() {\n            return [this._path, this._name];\n        }\n        /**\n         * Trigger a state change to rerender.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState[0] !== newState[0] || oldState[1] !== newState[1]) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    PathStatus.Model = Model;\n})(PathStatus || (PathStatus = {}));\n//# sourceMappingURL=pathstatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { VDomModel, VDomRenderer } from '@jupyterlab/apputils';\nimport { TextItem } from '@jupyterlab/statusbar';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport React from 'react';\n/**\n * A pure functional component for a Saving status item.\n *\n * @param props - the props for the component.\n *\n * @returns a tsx component for rendering the saving state.\n */\nfunction SavingStatusComponent(props) {\n    return React.createElement(TextItem, { source: props.fileStatus });\n}\n/**\n * The amount of time (in ms) to retain the saving completed message\n * before hiding the status item.\n */\nconst SAVING_COMPLETE_MESSAGE_MILLIS = 2000;\n/**\n * A VDomRenderer for a saving status item.\n */\nexport class SavingStatus extends VDomRenderer {\n    /**\n     * Create a new SavingStatus item.\n     */\n    constructor(opts) {\n        super(new SavingStatus.Model(opts.docManager));\n        const translator = opts.translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        this._statusMap = {\n            completed: trans.__('Saving completed'),\n            started: trans.__('Saving started'),\n            failed: trans.__('Saving failed')\n        };\n    }\n    /**\n     * Render the SavingStatus item.\n     */\n    render() {\n        if (this.model === null || this.model.status === null) {\n            return null;\n        }\n        else {\n            return (React.createElement(SavingStatusComponent, { fileStatus: this._statusMap[this.model.status] }));\n        }\n    }\n}\n/**\n * A namespace for SavingStatus statics.\n */\n(function (SavingStatus) {\n    /**\n     * A VDomModel for the SavingStatus item.\n     */\n    class Model extends VDomModel {\n        /**\n         * Create a new SavingStatus model.\n         */\n        constructor(docManager) {\n            super();\n            /**\n             * React to a saving status change from the current document widget.\n             */\n            this._onStatusChange = (_, newStatus) => {\n                this._status = newStatus;\n                if (this._status === 'completed') {\n                    setTimeout(() => {\n                        this._status = null;\n                        this.stateChanged.emit(void 0);\n                    }, SAVING_COMPLETE_MESSAGE_MILLIS);\n                    this.stateChanged.emit(void 0);\n                }\n                else {\n                    this.stateChanged.emit(void 0);\n                }\n            };\n            this._status = null;\n            this._widget = null;\n            this._status = null;\n            this.widget = null;\n            this._docManager = docManager;\n        }\n        /**\n         * The current status of the model.\n         */\n        get status() {\n            return this._status;\n        }\n        /**\n         * The current widget for the model. Any widget can be assigned,\n         * but it only has any effect if the widget is an IDocument widget\n         * known to the application document manager.\n         */\n        get widget() {\n            return this._widget;\n        }\n        set widget(widget) {\n            var _a, _b;\n            const oldWidget = this._widget;\n            if (oldWidget !== null) {\n                const oldContext = this._docManager.contextForWidget(oldWidget);\n                if (oldContext) {\n                    oldContext.saveState.disconnect(this._onStatusChange);\n                }\n                else if ((_a = this._widget.content) === null || _a === void 0 ? void 0 : _a.saveStateChanged) {\n                    this._widget.content.saveStateChanged.disconnect(this._onStatusChange);\n                }\n            }\n            this._widget = widget;\n            if (this._widget === null) {\n                this._status = null;\n            }\n            else {\n                const widgetContext = this._docManager.contextForWidget(this._widget);\n                if (widgetContext) {\n                    widgetContext.saveState.connect(this._onStatusChange);\n                }\n                else if ((_b = this._widget.content) === null || _b === void 0 ? void 0 : _b.saveStateChanged) {\n                    this._widget.content.saveStateChanged.connect(this._onStatusChange);\n                }\n            }\n        }\n    }\n    SavingStatus.Model = Model;\n})(SavingStatus || (SavingStatus = {}));\n//# sourceMappingURL=savingstatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The document registry token.\n */\nexport const IDocumentManager = new Token('@jupyterlab/docmanager:IDocumentManager');\n//# sourceMappingURL=tokens.js.map"],"names":["renameDialog","manager","oldPath","translator","trans","nullTranslator","load","showDialog","title","__","body","RenameHandler","focusNodeSelector","buttons","Dialog","label","then","result","value","isValidFileName","showErrorMessage","Error","basePath","PathExt","newPath","renameFile","rename","catch","error","response","status","shouldOverwrite","overwrite","Promise","reject","path","options","resolve","button","accept","name","length","test","Widget","constructor","super","node","Private","createRenameNode","this","addClass","ext","inputNode","setSelectionRange","getElementsByTagName","getValue","document","createElement","existingLabel","textContent","existingPath","nameTitle","className","appendChild","SaveHandler","_autosaveTimer","_minInterval","_interval","_isActive","_inDialog","_isDisposed","_multiplier","_context","context","interval","saveInterval","fileChanged","connect","_setTimer","disposed","dispose","isActive","isDisposed","clearTimeout","Signal","start","stop","window","setTimeout","_save","contentsModel","writable","model","dirty","Date","getTime","save","duration","Math","max","err","message","console","DocumentWidgetManager","_activateRequested","_confirmClosingTab","_stateChanged","_registry","registry","activateRequested","confirmClosingDocument","v","oldValue","emit","newValue","stateChanged","createWidget","factory","widget","createNew","_initializeWidget","factoryProperty","set","disposables","DisposableSet","each","widgetExtensions","extender","disposable","add","disposablesProperty","_onWidgetDisposed","adoptWidget","_onFileChanged","pathChanged","_onPathChanged","ready","setCaption","widgetsProperty","get","push","MessageLoop","closable","_widgetDisposed","contextProperty","findWidget","widgetName","widgets","find","contextForWidget","cloneWidget","newWidget","closeWidgets","all","toArray","map","onClose","deleteWidgets","onDelete","messageHook","handler","msg","type","async","listCheckpoints","checkpoints","last","checkpoint","Time","last_modified","caption","readOnly","_a","shouldClose","ignoreSave","_maybeClose","saveAs","_b","filter","fileName","isDirty","splice","confirm","checkbox","isChecked","displayType","saveLabel","ArrayExt","AttachedProperty","create","DocumentManager","_contexts","_autosave","_autosaveInterval","_lastModifiedCheckMargin","_renameUntitledFileOnSave","services","_dialogs","sessionDialogs","sessionContextDialogs","_docProviderFactory","docProviderFactory","_opener","opener","_when","when","widgetManager","_onActivateRequested","_onWidgetStateChanged","_widgetManager","_setBusy","setBusy","autosave","forEach","saveHandlerProperty","autosaveInterval","lastModifiedCheckMargin","renameUntitledFileOnSave","closeAll","closeFile","close","_contextsForPath","c","x","copy","fromFile","toDir","contents","kernel","_createOrOpenDocument","deleteFile","sessions","stopIfNeeded","delete","widgetNames","defaultWidgetFactory","preferredWidgetFactories","f","newUntitled","open","openOrReveal","tempPath","UUID","cb","_findContext","factoryName","normalizedPath","normalize","_createContext","kernelPreference","modelDBFactory","getModelDBFactory","undefined","Context","_onContextDisposed","_widgetFactoryFor","getWidgetFactory","which","widgetFactory","modelName","getModelFactory","preference","getKernelPreference","initialize","sender","args","PathStatusComponent","props","TextItem","source","fullPath","PathStatus","VDomRenderer","opts","Model","docManager","render","SavingStatusComponent","fileStatus","VDomModel","_onTitleChange","oldState","_getAllState","_name","_triggerChange","_onPathChange","_documentModel","_path","_widget","_docManager","oldWidget","oldContext","disconnect","changed","widgetContext","newState","SavingStatus","_statusMap","completed","started","failed","_onStatusChange","_","newStatus","_status","saveState","content","saveStateChanged","IDocumentManager","Token"],"sourceRoot":""}