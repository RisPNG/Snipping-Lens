name: Build and Release

permissions:
  contents: write # Required to create a release and upload assets

on:
  push:
    branches:
      - main # Adjust to your desired branch

jobs:
  build_and_release:
    # Only run if the commit message contains "Release v"
    if: contains(github.event.head_commit.message, 'Release v')
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest]
    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11" # Using a common stable version

      - name: Install Dependencies (Python)
        run: pip install -r requirements.txt

      - name: Install PyInstaller
        run: pip install pyinstaller==6.9.0 # Pinning for stability, adjust as needed

      # Linux specific setup for runtime dependencies (for PyInstaller hooks or testing, not bundled)
      - name: Install Linux tools (if Linux runner)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y xclip gnome-screenshot libx11-xcb1 libdbus-glib-1-2 # libdbus-glib for pystray/Gtk backend
          # Add any other libraries that Pillow or pystray might need for full functionality on Linux
          # For pystray with StatusNotifierItem, dbus-python and PyGObject are needed.
          # PyInstaller might bundle them if they are in requirements.txt or imported.
          # If not, pip install dbus-python pygobject

      - name: Extract release info from commit message
        id: extract_release_info
        # This step will run on both OS, but values are used later by the release step (which runs once)
        # For simplicity, it's defined here. Could be a separate job if preferred.
        shell: bash
        run: |
          commit_msg=$(git log -1 --pretty=%B)
          echo "Commit message:"
          echo "$commit_msg"
        
          version=$(echo "$commit_msg" | sed -n 's/.*Release v\([[:alnum:].\-]\+\).*/\1/p')
          description=$(echo "$commit_msg" | sed -n '/^~$/,/^~$/p' | sed '1d;$d')

          if [ -z "$version" ]; then
            echo "No valid release version found in the commit message. Exiting."
            exit 1
          fi
        
          if echo "$version" | grep -q '-'; then
            prerelease=true
          else
            prerelease=false
          fi

          echo "Version: $version"
          echo "Description (raw): $description" # For debugging
          echo "Prerelease: $prerelease"

          # Ensure description is properly escaped for multiline output
          description_escaped="${description//'%'/'%25'}"
          description_escaped="${description_escaped//$'\n'/'%0A'}"
          description_escaped="${description_escaped//$'\r'/'%0D'}"
          
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "description_content<<EOF" >> $GITHUB_OUTPUT
          echo "$description" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "prerelease=$prerelease" >> $GITHUB_OUTPUT
          echo "tag_name=v$version" >> $GITHUB_OUTPUT
          echo "release_name=v$version" >> $GITHUB_OUTPUT


      - name: Build executable (Windows)
        if: runner.os == 'Windows'
        run: |
          pyinstaller --onefile --windowed --name "SnippingLens" --icon="my_icon.ico" --add-data="my_icon.png;." snipping_lens.py
          
      - name: Build executable (Linux)
        if: runner.os == 'Linux'
        run: |
          # The --icon option for PyInstaller on Linux doesn't embed into ELF like on Windows.
          # It's primarily for macOS bundles. The icon is usually handled by the .desktop file.
          # We add my_icon.png to be bundled, as resource_path can find it for the tray and .desktop file.
          pyinstaller --onefile --name "SnippingLens" --add-data="my_icon.png:." snipping_lens.py
          # To make it an AppImage (conceptual, requires AppImage tools setup):
          # 1. mkdir AppDir
          # 2. Copy executable to AppDir/usr/bin/
          # 3. Copy icon to AppDir/usr/share/icons/ (and AppDir root)
          # 4. Create AppDir/AppRun script
          # 5. Create AppDir/snippinglens.desktop
          # 6. appimagetool AppDir SnippingLens.AppImage
          # This workflow will upload the raw executable for now.

      - name: Archive executable (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: SnippingLens-Windows
          path: dist/SnippingLens.exe

      - name: Archive executable (Linux)
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: SnippingLens-Linux
          path: dist/SnippingLens # PyInstaller output name on Linux

  # This job runs after all build jobs are complete
  create_github_release:
    needs: build_and_release # Depends on the matrix job completion
    runs-on: ubuntu-latest # Can be any OS, just needs to run once
    # Ensure this job also only runs if the commit message is right
    if: success() && contains(github.event.head_commit.message, 'Release v')

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts # All artifacts will be downloaded to 'artifacts' directory

      # The extract_release_info step in the matrix job already creates the outputs.
      # We need a way to get those outputs here.
      # A simpler way is to re-run the extraction or pass via artifacts.
      # For now, let's assume the first build job's output can be used, or re-extract.
      # Re-extracting is cleaner if the matrix runs in parallel.
      - name: Extract release info from commit message (for release job)
        id: extract_release_info_for_release
        shell: bash
        run: |
          commit_msg=$(git log -1 --pretty=%B) # Assuming commit is available
          version=$(echo "$commit_msg" | sed -n 's/.*Release v\([[:alnum:].\-]\+\).*/\1/p')
          description=$(echo "$commit_msg" | sed -n '/^~$/,/^~$/p' | sed '1d;$d')
          if [ -z "$version" ]; then echo "No version in commit."; exit 1; fi
          if echo "$version" | grep -q '-'; then prerelease=true; else prerelease=false; fi
          
          echo "version=$version" >> $GITHUB_OUTPUT
          # Prepare description for multiline JSON compatibility in release body
          echo "description_content<<EOF" >> $GITHUB_OUTPUT
          echo "$description" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "prerelease=$prerelease" >> $GITHUB_OUTPUT
          echo "tag_name=v$version" >> $GITHUB_OUTPUT
          echo "release_name=v$version" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.extract_release_info_for_release.outputs.tag_name }}
          release_name: ${{ steps.extract_release_info_for_release.outputs.release_name }}
          body: ${{ steps.extract_release_info_for_release.outputs.description_content }}
          draft: false
          prerelease: ${{ steps.extract_release_info_for_release.outputs.prerelease }}

      - name: Upload Windows Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: artifacts/SnippingLens-Windows/SnippingLens.exe
          asset_name: SnippingLens-Windows.exe
          asset_content_type: application/vnd.microsoft.portable-executable

      - name: Upload Linux Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: artifacts/SnippingLens-Linux/SnippingLens
          asset_name: SnippingLens-Linux_x86_64 # More descriptive name
          asset_content_type: application/x-executable # Or application/octet-stream